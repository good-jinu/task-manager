import { signIn } from "@auth/sveltekit/client";
import type { Task } from "@notion-task-manager/db";
import { get } from "svelte/store";
import { browser } from "$app/environment";
import { appState } from "$lib/stores/app-state";
import { isGuestMode, updateGuestTaskCount } from "$lib/stores/guest";
import {
	type ComponentEvent,
	useComponentWiring,
} from "$lib/utils/component-wiring";
import { guestUserService } from "./guest-user-service";
import { setupMigration } from "./migration-service";
import { taskService } from "./task-service";

const manager = useComponentWiring().manager;

/**
 * Refresh tasks for current workspace
 */
async function refreshCurrentWorkspaceTasks(): Promise<void> {
	const currentState = get(appState);
	if (currentState.currentWorkspace) {
		try {
			const tasks = await taskService.fetchTasks(
				currentState.currentWorkspace.id,
			);
			handleTasksUpdate(tasks);
		} catch (error) {
			console.error("Failed to refresh tasks:", error);
		}
	}
}

/**
 * Update task count for guest users
 */
function updateTaskCount(tasks: Task[]): void {
	const isGuest = get(isGuestMode);
	if (isGuest) {
		appState.updateGuestStats(tasks.length);
		updateGuestTaskCount(tasks.length);
	}
}

/**
 * Save guest data to localStorage
 */
function saveGuestData(tasks: Task[]): void {
	const isGuest = get(isGuestMode);
	const currentState = get(appState);

	if (isGuest && currentState.currentWorkspace) {
		guestUserService.saveGuestData({
			guestId: "guest",
			workspaceId: currentState.currentWorkspace.id,
			tasks: tasks,
			lastSync: new Date().toISOString(),
			deviceFingerprint: "", // Will be generated by the service
		});
	}
}

/**
 * Handle component events from the wiring system
 */
export function handleComponentEvent(event: ComponentEvent): void {
	switch (event.type) {
		case "oauth_completed":
			if (event.success && event.workspaceId) {
				// OAuth successful, database selection dialog should open
				// This is handled by the component wiring manager
			}
			break;

		case "integration_created":
			// Refresh tasks after integration is created
			refreshCurrentWorkspaceTasks();
			break;

		case "guest_upgrade_prompted":
			// Show account dialog for guest upgrade
			manager.showAccountDialog();
			break;

		case "error_occurred":
			// Error handling is managed by error state manager
			console.error("Component error:", event.error, event.context);
			break;

		case "performance_measured":
			// Log performance metrics
			if (event.duration > 1000) {
				// Log slow operations
				console.warn(
					`Slow operation detected: ${event.metric} took ${event.duration}ms`,
				);
			}
			break;
	}
}

/**
 * Handle menu actions from the top menu
 */
export function handleMenuAction(action: string): void {
	switch (action) {
		case "signup":
			manager.showAccountDialog();
			break;
		case "notion":
		case "settings":
			handleOpenSettingsDrawer();
			break;
		case "home":
			// Navigate to home or refresh current view
			if (browser) {
				window.location.href = "/";
			}
			break;
		default:
			console.log("Menu action:", action);
	}
}

/**
 * Handle task updates
 */
export function handleTasksUpdate(updatedTasks: Task[]): void {
	appState.setTasks(updatedTasks);
	manager.updateState({ tasks: updatedTasks });
	updateTaskCount(updatedTasks);
	saveGuestData(updatedTasks);
}

/**
 * Handle context task toggle
 */
export function handleContextToggle(taskId: string): void {
	appState.toggleContextTask(taskId);
}

/**
 * Handle clearing context
 */
export function handleClearContext(): void {
	appState.clearContextTasks();
}

/**
 * Handle guest sign up
 */
export function handleGuestSignUp(): void {
	manager.showAccountDialog();
}

/**
 * Handle Notion login with guest data migration
 */
export async function handleNotionLogin(migrateData: boolean): Promise<void> {
	if (!browser) {
		throw new Error("Login can only be initiated from the browser");
	}

	try {
		const currentState = get(appState);
		const hasGuestData =
			currentState.tasks.length > 0 || localStorage.getItem("guest-id");

		// Store migration preference for after authentication
		setupMigration(Boolean(migrateData) && Boolean(hasGuestData));

		// Initiate Notion OAuth flow
		await signIn("notion", {
			callbackUrl: window.location.origin,
			redirect: true,
		});
	} catch (error) {
		console.error("Notion login failed:", error);
		throw error;
	}
}

/**
 * Handle opening settings drawer
 */
export async function handleOpenSettingsDrawer(): Promise<void> {
	const currentState = get(appState);
	if (currentState.currentWorkspace) {
		await manager.openSettingsDrawer(currentState.currentWorkspace.id);
	}
}

/**
 * Handle closing settings drawer
 */
export function handleCloseSettingsDrawer(): void {
	manager.closeSettingsDrawer();
}

/**
 * Handle integration toggle
 */
export async function handleToggleIntegration(
	provider: string,
	enabled: boolean,
): Promise<void> {
	const currentState = get(appState);
	if (currentState.currentWorkspace) {
		await manager.toggleIntegration(
			provider,
			enabled,
			currentState.currentWorkspace.id,
		);
	}
}

/**
 * Handle Notion connection
 */
export async function handleConnectNotion(
	databaseId: string,
	importExisting: boolean,
): Promise<void> {
	const currentState = get(appState);
	if (currentState.currentWorkspace) {
		await manager.selectDatabase(
			databaseId,
			currentState.currentWorkspace.id,
			importExisting,
		);
	}
}

/**
 * Handle integration disconnection
 */
export async function handleDisconnectIntegration(
	integrationId: string,
): Promise<void> {
	const currentState = get(appState);
	if (currentState.currentWorkspace) {
		await manager.disconnectIntegration(
			integrationId,
			currentState.currentWorkspace.id,
		);
	}
}

/**
 * Handle global keyboard events
 */
export function handleGlobalKeyDown(event: KeyboardEvent): void {
	// Handle escape key to close settings drawer
	if (event.key === "Escape") {
		// Check if settings drawer is open through component wiring
		const componentState = manager.getState();
		if (componentState.settingsDrawerOpen) {
			manager.closeSettingsDrawer();
			event.preventDefault();
		}
	}
}
